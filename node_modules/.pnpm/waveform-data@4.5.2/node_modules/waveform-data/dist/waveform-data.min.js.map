{"version":3,"file":"waveform-data.min.js","sources":["../src/waveform-data-channel.js","../src/waveform-generator.js","../src/utils.js","../src/waveform-data.js","../src/waveform-utils.js"],"sourcesContent":["/**\n * Provides access to the waveform data for a single audio channel.\n */\n\nfunction WaveformDataChannel(waveformData, channelIndex) {\n  this._waveformData = waveformData;\n  this._channelIndex = channelIndex;\n}\n\n/**\n * Returns the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.min_sample = function(index) {\n  const offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Returns the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.max_sample = function(index) {\n  const offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._at(offset);\n};\n\n/**\n * Sets the waveform minimum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_min_sample = function(index, sample) {\n  const offset = (index * this._waveformData.channels + this._channelIndex) * 2;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Sets the waveform maximum at the given index position.\n */\n\nWaveformDataChannel.prototype.set_max_sample = function(index, sample) {\n  const offset = (index * this._waveformData.channels + this._channelIndex) * 2 + 1;\n\n  return this._waveformData._set_at(offset, sample);\n};\n\n/**\n * Returns all the waveform minimum values as an array.\n */\n\nWaveformDataChannel.prototype.min_array = function() {\n  const length = this._waveformData.length;\n  const values = [];\n\n  for (let i = 0; i < length; i++) {\n    values.push(this.min_sample(i));\n  }\n\n  return values;\n};\n\n/**\n * Returns all the waveform maximum values as an array.\n */\n\nWaveformDataChannel.prototype.max_array = function() {\n  const length = this._waveformData.length;\n  const values = [];\n\n  for (let i = 0; i < length; i++) {\n    values.push(this.max_sample(i));\n  }\n\n  return values;\n};\n\nexport default WaveformDataChannel;\n","/**\n * AudioBuffer-based WaveformData generator\n *\n * Adapted from BlockFile::CalcSummary in Audacity, with permission.\n * See https://github.com/audacity/audacity/blob/\n *   1108c1376c09166162335fab4743008cba57c4ee/src/BlockFile.cpp#L198\n */\n\nconst INT8_MAX = 127;\nconst INT8_MIN = -128;\n\nconst INT16_MAX = 32767;\nconst INT16_MIN = -32768;\n\nfunction calculateWaveformDataLength(audio_sample_count, scale) {\n  let data_length = Math.floor(audio_sample_count / scale);\n\n  const samples_remaining = audio_sample_count - (data_length * scale);\n\n  if (samples_remaining > 0) {\n    data_length++;\n  }\n\n  return data_length;\n}\n\nfunction generateWaveformData(options) {\n  const scale = options.scale;\n  const amplitude_scale = options.amplitude_scale;\n  const split_channels = options.split_channels;\n  const length = options.length;\n  const sample_rate = options.sample_rate;\n  const channels = options.channels.map(function(channel) {\n    return new Float32Array(channel);\n  });\n  const output_channels = split_channels ? channels.length : 1;\n  const header_size = 24;\n  const data_length = calculateWaveformDataLength(length, scale);\n  const bytes_per_sample = options.bits === 8 ? 1 : 2;\n  const total_size = header_size + data_length * 2 * bytes_per_sample * output_channels;\n  const buffer = new ArrayBuffer(total_size);\n  const data_view = new DataView(buffer);\n\n  let scale_counter = 0;\n  let offset = header_size;\n\n  const min_value = new Array(output_channels);\n  const max_value = new Array(output_channels);\n\n  for (let channel = 0; channel < output_channels; channel++) {\n    min_value[channel] = Infinity;\n    max_value[channel] = -Infinity;\n  }\n\n  const range_min = options.bits === 8 ? INT8_MIN : INT16_MIN;\n  const range_max = options.bits === 8 ? INT8_MAX : INT16_MAX;\n\n  data_view.setInt32(0, 2, true); // Version\n  data_view.setUint32(4, options.bits === 8, true); // Is 8 bit?\n  data_view.setInt32(8, sample_rate, true); // Sample rate\n  data_view.setInt32(12, scale, true); // Scale\n  data_view.setInt32(16, data_length, true); // Length\n  data_view.setInt32(20, output_channels, true);\n\n  for (let i = 0; i < length; i++) {\n    let sample = 0;\n\n    if (output_channels === 1) {\n      for (let channel = 0; channel < channels.length; ++channel) {\n        sample += channels[channel][i];\n      }\n\n      sample = Math.floor(range_max * sample * amplitude_scale / channels.length);\n\n      if (sample < min_value[0]) {\n        min_value[0] = sample;\n\n        if (min_value[0] < range_min) {\n          min_value[0] = range_min;\n        }\n      }\n\n      if (sample > max_value[0]) {\n        max_value[0] = sample;\n\n        if (max_value[0] > range_max) {\n          max_value[0] = range_max;\n        }\n      }\n    }\n    else {\n      for (let channel = 0; channel < output_channels; ++channel) {\n        sample = Math.floor(range_max * channels[channel][i] * amplitude_scale);\n\n        if (sample < min_value[channel]) {\n          min_value[channel] = sample;\n\n          if (min_value[channel] < range_min) {\n            min_value[channel] = range_min;\n          }\n        }\n\n        if (sample > max_value[channel]) {\n          max_value[channel] = sample;\n\n          if (max_value[channel] > range_max) {\n            max_value[channel] = range_max;\n          }\n        }\n      }\n    }\n\n    if (++scale_counter === scale) {\n      for (let channel = 0; channel < output_channels; channel++) {\n        if (options.bits === 8) {\n          data_view.setInt8(offset++, min_value[channel]);\n          data_view.setInt8(offset++, max_value[channel]);\n        }\n        else {\n          data_view.setInt16(offset, min_value[channel], true);\n          data_view.setInt16(offset + 2, max_value[channel], true);\n          offset += 4;\n        }\n\n        min_value[channel] = Infinity;\n        max_value[channel] = -Infinity;\n      }\n\n      scale_counter = 0;\n    }\n  }\n\n  if (scale_counter > 0) {\n    for (let channel = 0; channel < output_channels; channel++) {\n      if (options.bits === 8) {\n        data_view.setInt8(offset++, min_value[channel]);\n        data_view.setInt8(offset++, max_value[channel]);\n      }\n      else {\n        data_view.setInt16(offset, min_value[channel], true);\n        data_view.setInt16(offset + 2, max_value[channel], true);\n      }\n    }\n  }\n\n  return buffer;\n}\n\nexport { generateWaveformData };\n","export function isNullOrUndefined(value) {\n  return value === undefined || value === null;\n}\n","import WaveformDataChannel from './waveform-data-channel';\nimport { generateWaveformData } from './waveform-generator';\nimport { isJsonWaveformData, isBinaryWaveformData, convertJsonToBinary } from './waveform-utils';\nimport { isNullOrUndefined } from './utils';\nimport WaveformDataWorker from 'web-worker:./waveform-data-worker';\n\n/**\n * Provides access to waveform data.\n */\n\nfunction WaveformData(data) {\n  if (isJsonWaveformData(data)) {\n    data = convertJsonToBinary(data);\n  }\n\n  if (isBinaryWaveformData(data)) {\n    this._data = new DataView(data);\n    this._offset = this._version() === 2 ? 24 : 20;\n\n    this._channels = [];\n\n    for (let channel = 0; channel < this.channels; channel++) {\n      this._channels[channel] = new WaveformDataChannel(this, channel);\n    }\n  }\n  else {\n    throw new TypeError(\n      'WaveformData.create(): Unknown data format'\n    );\n  }\n}\n\nconst defaultOptions = {\n  scale: 512,\n  bits: 8,\n  amplitude_scale: 1.0,\n  split_channels: false,\n  disable_worker: false\n};\n\nfunction getOptions(options) {\n  const opts = {\n    scale: options.scale || defaultOptions.scale,\n    bits: options.bits || defaultOptions.bits,\n    amplitude_scale: options.amplitude_scale || defaultOptions.amplitude_scale,\n    split_channels: options.split_channels || defaultOptions.split_channels,\n    disable_worker: options.disable_worker || defaultOptions.disable_worker\n  };\n\n  return opts;\n}\n\nfunction getChannelData(audio_buffer) {\n  const channels = [];\n\n  for (let i = 0; i < audio_buffer.numberOfChannels; ++i) {\n    channels.push(audio_buffer.getChannelData(i).buffer);\n  }\n\n  return channels;\n}\n\nfunction createFromAudioBuffer(audio_buffer, options, callback) {\n  const channels = getChannelData(audio_buffer);\n\n  if (options.disable_worker) {\n    const buffer = generateWaveformData({\n      scale: options.scale,\n      bits: options.bits,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    });\n\n    callback(undefined, new WaveformData(buffer), audio_buffer);\n  }\n  else {\n    const worker = new WaveformDataWorker();\n\n    worker.onmessage = function(evt) {\n      callback(undefined, new WaveformData(evt.data), audio_buffer);\n    };\n\n    worker.postMessage({\n      scale: options.scale,\n      bits: options.bits,\n      amplitude_scale: options.amplitude_scale,\n      split_channels: options.split_channels,\n      length: audio_buffer.length,\n      sample_rate: audio_buffer.sampleRate,\n      channels: channels\n    }, channels);\n  }\n}\n\nfunction createFromArrayBuffer(audioContext, audioData, options, callback) {\n  // The following function is a workaround for a Webkit bug where decodeAudioData\n  // invokes the errorCallback with null instead of a DOMException.\n  // See https://webaudio.github.io/web-audio-api/#dom-baseaudiocontext-decodeaudiodata\n  // and http://stackoverflow.com/q/10365335/103396\n\n  function errorCallback(error) {\n    if (!error) {\n      error = new DOMException('EncodingError');\n    }\n\n    callback(error);\n    // prevent double-calling the callback on errors:\n    callback = function() { };\n  }\n\n  const promise = audioContext.decodeAudioData(\n    audioData,\n    function(audio_buffer) {\n      createFromAudioBuffer(audio_buffer, options, callback);\n    },\n    errorCallback\n  );\n\n  if (promise) {\n    promise.catch(errorCallback);\n  }\n}\n\n/**\n * Creates and returns a WaveformData instance from the given waveform data.\n */\n\nWaveformData.create = function create(data) {\n  return new WaveformData(data);\n};\n\n/**\n * Creates a WaveformData instance from audio.\n */\n\nWaveformData.createFromAudio = function(options, callback) {\n  const opts = getOptions(options);\n\n  if (options.audio_context && options.array_buffer) {\n    return createFromArrayBuffer(options.audio_context, options.array_buffer, opts, callback);\n  }\n  else if (options.audio_buffer) {\n    return createFromAudioBuffer(options.audio_buffer, opts, callback);\n  }\n  else {\n    throw new TypeError(\n      // eslint-disable-next-line\n      'WaveformData.createFromAudio(): Pass either an AudioContext and ArrayBuffer, or an AudioBuffer object'\n    );\n  }\n};\n\nfunction WaveformResampler(options) {\n  this._inputData = options.waveformData;\n\n  // Scale we want to reach\n  this._output_samples_per_pixel = options.scale;\n\n  this._scale = this._inputData.scale; // scale we are coming from\n\n  // The amount of data we want to resample i.e. final zoom want to resample\n  // all data but for intermediate zoom we want to resample subset\n  this._input_buffer_size = this._inputData.length;\n\n  const input_buffer_length_samples = this._input_buffer_size * this._inputData.scale;\n  const output_buffer_length_samples =\n    Math.ceil(input_buffer_length_samples / this._output_samples_per_pixel);\n\n  const output_header_size = 24; // version 2\n  const bytes_per_sample = this._inputData.bits === 8 ? 1 : 2;\n  const total_size = output_header_size\n                   + output_buffer_length_samples * 2 * this._inputData.channels * bytes_per_sample;\n\n  this._output_data = new ArrayBuffer(total_size);\n\n  this.output_dataview = new DataView(this._output_data);\n\n  this.output_dataview.setInt32(0, 2, true); // Version\n  this.output_dataview.setUint32(4, this._inputData.bits === 8, true); // Is 8 bit?\n  this.output_dataview.setInt32(8, this._inputData.sample_rate, true);\n  this.output_dataview.setInt32(12, this._output_samples_per_pixel, true);\n  this.output_dataview.setInt32(16, output_buffer_length_samples, true);\n  this.output_dataview.setInt32(20, this._inputData.channels, true);\n\n  this._outputWaveformData = new WaveformData(this._output_data);\n\n  this._input_index = 0;\n  this._output_index = 0;\n\n  const channels = this._inputData.channels;\n\n  this._min = new Array(channels);\n  this._max = new Array(channels);\n\n  for (let channel = 0; channel < channels; ++channel) {\n    if (this._input_buffer_size > 0) {\n      this._min[channel] = this._inputData.channel(channel).min_sample(this._input_index);\n      this._max[channel] = this._inputData.channel(channel).max_sample(this._input_index);\n    }\n    else {\n      this._min[channel] = 0;\n      this._max[channel] = 0;\n    }\n  }\n\n  this._min_value = this._inputData.bits === 8 ? -128 : -32768;\n  this._max_value = this._inputData.bits === 8 ?  127 :  32767;\n\n  this._where = 0;\n  this._prev_where = 0;\n  this._stop = 0;\n  this._last_input_index = 0;\n}\n\nWaveformResampler.prototype.sample_at_pixel = function(x) {\n  return Math.floor(x * this._output_samples_per_pixel);\n};\n\nWaveformResampler.prototype.next = function() {\n  let count = 0;\n  const total = 1000;\n  const channels = this._inputData.channels;\n  let channel;\n\n  while (this._input_index < this._input_buffer_size && count < total) {\n    while (Math.floor(this.sample_at_pixel(this._output_index) / this._scale) ===\n           this._input_index) {\n      if (this._output_index > 0) {\n        for (let i = 0; i < channels; ++i) {\n          channel = this._outputWaveformData.channel(i);\n\n          channel.set_min_sample(this._output_index - 1, this._min[i]);\n          channel.set_max_sample(this._output_index - 1, this._max[i]);\n        }\n      }\n\n      this._last_input_index = this._input_index;\n\n      this._output_index++;\n\n      this._where      = this.sample_at_pixel(this._output_index);\n      this._prev_where = this.sample_at_pixel(this._output_index - 1);\n\n      if (this._where !== this._prev_where) {\n        for (let i = 0; i < channels; ++i) {\n          this._min[i] = this._max_value;\n          this._max[i] = this._min_value;\n        }\n      }\n    }\n\n    this._where = this.sample_at_pixel(this._output_index);\n    this._stop = Math.floor(this._where / this._scale);\n\n    if (this._stop > this._input_buffer_size) {\n      this._stop = this._input_buffer_size;\n    }\n\n    while (this._input_index < this._stop) {\n      for (let i = 0; i < channels; ++i) {\n        channel = this._inputData.channel(i);\n\n        let value = channel.min_sample(this._input_index);\n\n        if (value < this._min[i]) {\n          this._min[i] = value;\n        }\n\n        value = channel.max_sample(this._input_index);\n\n        if (value > this._max[i]) {\n          this._max[i] = value;\n        }\n      }\n\n      this._input_index++;\n    }\n\n    count++;\n  }\n\n  if (this._input_index < this._input_buffer_size) {\n    // More to do\n    return false;\n  }\n  else {\n    // Done\n    if (this._input_index !== this._last_input_index) {\n      for (let i = 0; i < channels; ++i) {\n        channel = this._outputWaveformData.channel(i);\n\n        channel.set_min_sample(this._output_index - 1, this._min[i]);\n        channel.set_max_sample(this._output_index - 1, this._max[i]);\n      }\n    }\n\n    return true;\n  }\n};\n\nWaveformResampler.prototype.getOutputData = function() {\n  return this._output_data;\n};\n\nWaveformData.prototype = {\n\n  _getResampleOptions(options) {\n    const opts = {};\n\n    opts.scale = options.scale;\n    opts.width = options.width;\n\n    if (!isNullOrUndefined(opts.width) && (typeof opts.width !== 'number' || opts.width <= 0)) {\n      throw new RangeError('WaveformData.resample(): width should be a positive integer value');\n    }\n\n    if (!isNullOrUndefined(opts.scale) && (typeof opts.scale !== 'number' || opts.scale <= 0)) {\n      throw new RangeError('WaveformData.resample(): scale should be a positive integer value');\n    }\n\n    if (!opts.scale && !opts.width) {\n      throw new Error('WaveformData.resample(): Missing scale or width option');\n    }\n\n    if (opts.width) {\n      // Calculate the target scale for the resampled waveform\n      opts.scale = Math.floor(this.duration * this.sample_rate / opts.width);\n    }\n\n    if (opts.scale < this.scale) {\n      throw new Error(\n        'WaveformData.resample(): Zoom level ' + opts.scale +\n        ' too low, minimum: ' + this.scale\n      );\n    }\n\n    opts.abortSignal = options.abortSignal;\n\n    return opts;\n  },\n\n  resample: function(options) {\n    options = this._getResampleOptions(options);\n    options.waveformData = this;\n\n    const resampler = new WaveformResampler(options);\n\n    while (!resampler.next()) {\n      // nothing\n    }\n\n    return new WaveformData(resampler.getOutputData());\n  },\n\n  /**\n   * Concatenates with one or more other waveforms, returning a new WaveformData object.\n   */\n\n  concat: function() {\n    const self = this;\n    const otherWaveforms = Array.prototype.slice.call(arguments);\n\n    // Check that all the supplied waveforms are compatible\n    otherWaveforms.forEach(function(otherWaveform) {\n      if (self.channels !== otherWaveform.channels ||\n        self.sample_rate !== otherWaveform.sample_rate ||\n        self.bits !== otherWaveform.bits ||\n        self.scale !== otherWaveform.scale) {\n        throw new Error('WaveformData.concat(): Waveforms are incompatible');\n      }\n    });\n\n    const combinedBuffer = this._concatBuffers.apply(this, otherWaveforms);\n\n    return WaveformData.create(combinedBuffer);\n  },\n\n  /**\n   * Returns a new ArrayBuffer with the concatenated waveform.\n   * All waveforms must have identical metadata (version, channels, etc)\n   */\n\n  _concatBuffers: function() {\n    const otherWaveforms = Array.prototype.slice.call(arguments);\n    const headerSize = this._offset;\n    let totalSize = headerSize;\n    let totalDataLength = 0;\n    const bufferCollection = [this].concat(otherWaveforms).map(function(w) {\n      return w._data.buffer;\n    });\n\n    for (let i = 0; i < bufferCollection.length; i++) {\n      const buffer = bufferCollection[i];\n      const dataSize = new DataView(buffer).getInt32(16, true);\n\n      totalSize += buffer.byteLength - headerSize;\n      totalDataLength += dataSize;\n    }\n\n    const totalBuffer = new ArrayBuffer(totalSize);\n    const sourceHeader = new DataView(bufferCollection[0]);\n    const totalBufferView = new DataView(totalBuffer);\n\n    // Copy the header from the first chunk\n    for (let i = 0; i < headerSize; i++) {\n      totalBufferView.setUint8(i, sourceHeader.getUint8(i));\n    }\n\n    // Rewrite the data-length header item to reflect all of the samples concatenated together\n    totalBufferView.setInt32(16, totalDataLength, true);\n\n    let offset = 0;\n    const dataOfTotalBuffer = new Uint8Array(totalBuffer, headerSize);\n\n    for (let i = 0; i < bufferCollection.length; i++) {\n      const buffer = bufferCollection[i];\n\n      dataOfTotalBuffer.set(new Uint8Array(buffer, headerSize), offset);\n      offset += buffer.byteLength - headerSize;\n    }\n\n    return totalBuffer;\n  },\n\n  slice: function(options) {\n    let startIndex = 0;\n    let endIndex = 0;\n\n    if (!isNullOrUndefined(options.startIndex) && !isNullOrUndefined(options.endIndex)) {\n      startIndex = options.startIndex;\n      endIndex = options.endIndex;\n    }\n    else if (!isNullOrUndefined(options.startTime) && !isNullOrUndefined(options.endTime)) {\n      startIndex = this.at_time(options.startTime);\n      endIndex = this.at_time(options.endTime);\n    }\n\n    if (startIndex < 0) {\n      throw new RangeError('startIndex or startTime must not be negative');\n    }\n\n    if (endIndex < 0) {\n      throw new RangeError('endIndex or endTime must not be negative');\n    }\n\n    if (startIndex > this.length) {\n      startIndex = this.length;\n    }\n\n    if (endIndex > this.length) {\n      endIndex = this.length;\n    }\n\n    if (startIndex > endIndex) {\n      startIndex = endIndex;\n    }\n\n    const length = endIndex - startIndex;\n\n    const header_size = 24; // Version 2\n    const bytes_per_sample = this.bits === 8 ? 1 : 2;\n    const total_size = header_size\n                     + length * 2 * this.channels * bytes_per_sample;\n\n    const output_data = new ArrayBuffer(total_size);\n    const output_dataview = new DataView(output_data);\n\n    output_dataview.setInt32(0, 2, true); // Version\n    output_dataview.setUint32(4, this.bits === 8, true); // Is 8 bit?\n    output_dataview.setInt32(8, this.sample_rate, true);\n    output_dataview.setInt32(12, this.scale, true);\n    output_dataview.setInt32(16, length, true);\n    output_dataview.setInt32(20, this.channels, true);\n\n    for (let i = 0; i < length * this.channels * 2; i++) {\n      const sample = this._at(startIndex * this.channels * 2 + i);\n\n      if (this.bits === 8) {\n        output_dataview.setInt8(header_size + i, sample);\n      }\n      else {\n        output_dataview.setInt16(header_size + i * 2, sample, true);\n      }\n    }\n\n    return new WaveformData(output_data);\n  },\n\n  /**\n   * Returns the data format version number.\n   */\n\n  _version: function() {\n    return this._data.getInt32(0, true);\n  },\n\n  /**\n   * Returns the length of the waveform, in pixels.\n   */\n\n  get length() {\n    return this._data.getUint32(16, true);\n  },\n\n  /**\n   * Returns the number of bits per sample, either 8 or 16.\n   */\n\n  get bits() {\n    const bits = Boolean(this._data.getUint32(4, true));\n\n    return bits ? 8 : 16;\n  },\n\n  /**\n   * Returns the (approximate) duration of the audio file, in seconds.\n   */\n\n  get duration() {\n    return this.length * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of pixels per second.\n   */\n\n  get pixels_per_second() {\n    return this.sample_rate / this.scale;\n  },\n\n  /**\n   * Returns the amount of time represented by a single pixel, in seconds.\n   */\n\n  get seconds_per_pixel() {\n    return this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns the number of waveform channels.\n   */\n\n  get channels() {\n    if (this._version() === 2) {\n      return this._data.getInt32(20, true);\n    }\n    else {\n      return 1;\n    }\n  },\n\n  /**\n   * Returns a waveform channel.\n   */\n\n  channel: function(index) {\n    if (index >= 0 && index < this._channels.length) {\n      return this._channels[index];\n    }\n    else {\n      throw new RangeError('Invalid channel: ' + index);\n    }\n  },\n\n  /**\n   * Returns the number of audio samples per second.\n   */\n\n  get sample_rate() {\n    return this._data.getInt32(8, true);\n  },\n\n  /**\n   * Returns the number of audio samples per pixel.\n   */\n\n  get scale() {\n    return this._data.getInt32(12, true);\n  },\n\n  /**\n   * Returns a waveform data value at a specific offset.\n   */\n\n  _at: function at_sample(index) {\n    if (this.bits === 8) {\n      return this._data.getInt8(this._offset + index);\n    }\n    else {\n      return this._data.getInt16(this._offset + index * 2, true);\n    }\n  },\n\n  /**\n   * Sets a waveform data value at a specific offset.\n   */\n\n  _set_at: function set_at(index, sample) {\n    if (this.bits === 8) {\n      return this._data.setInt8(this._offset + index, sample);\n    }\n    else {\n      return this._data.setInt16(this._offset + index * 2, sample, true);\n    }\n  },\n\n  /**\n   * Returns the waveform data index position for a given time.\n   */\n\n  at_time: function at_time(time) {\n    return Math.floor(time * this.sample_rate / this.scale);\n  },\n\n  /**\n   * Returns the time in seconds for a given index.\n   */\n\n  time: function time(index) {\n    return index * this.scale / this.sample_rate;\n  },\n\n  /**\n   * Returns an object containing the waveform data.\n   */\n\n  toJSON: function() {\n    const waveform = {\n      version: 2,\n      channels: this.channels,\n      sample_rate: this.sample_rate,\n      samples_per_pixel: this.scale,\n      bits: this.bits,\n      length: this.length,\n      data: []\n    };\n\n    for (let i = 0; i < this.length; i++) {\n      for (let channel = 0; channel < this.channels; channel++) {\n        waveform.data.push(this.channel(channel).min_sample(i));\n        waveform.data.push(this.channel(channel).max_sample(i));\n      }\n    }\n\n    return waveform;\n  },\n\n  /**\n   * Returns the waveform data in binary format as an ArrayBuffer.\n   */\n\n  toArrayBuffer: function() {\n    return this._data.buffer;\n  }\n};\n\nexport default WaveformData;\n","export function isJsonWaveformData(data) {\n  return data &&\n    typeof data === 'object' &&\n    'sample_rate' in data &&\n    'samples_per_pixel' in data &&\n    'bits' in data &&\n    'length' in data &&\n    'data' in data;\n}\n\nexport function isBinaryWaveformData(data) {\n  const isCompatible = data && typeof data === 'object' && 'byteLength' in data;\n\n  if (isCompatible) {\n    const view = new DataView(data);\n    const version = view.getInt32(0, true);\n\n    if (version !== 1 && version !== 2) {\n      throw new TypeError('WaveformData.create(): This waveform data version not supported');\n    }\n  }\n\n  return isCompatible;\n}\n\nexport function convertJsonToBinary(data) {\n  const waveformData = data.data;\n  const channels = data.channels || 1;\n  const header_size = 24; // version 2\n  const bytes_per_sample = data.bits === 8 ? 1 : 2;\n  const expected_length = data.length * 2 * channels;\n\n  if (waveformData.length !== expected_length) {\n    throw new Error('WaveformData.create(): Length mismatch in JSON waveform data');\n  }\n\n  const total_size = header_size + waveformData.length * bytes_per_sample;\n\n  const array_buffer = new ArrayBuffer(total_size);\n  const data_object = new DataView(array_buffer);\n\n  data_object.setInt32(0, 2, true); // Version\n  data_object.setUint32(4, data.bits === 8, true);\n  data_object.setInt32(8, data.sample_rate, true);\n  data_object.setInt32(12, data.samples_per_pixel, true);\n  data_object.setInt32(16, data.length, true);\n  data_object.setInt32(20, channels, true);\n\n  let index = header_size;\n\n  if (data.bits === 8) {\n    for (let i = 0; i < waveformData.length; i++) {\n      data_object.setInt8(index++, waveformData[i], true);\n    }\n  }\n  else {\n    for (let i = 0; i < waveformData.length; i++) {\n      data_object.setInt16(index, waveformData[i], true);\n\n      index += 2;\n    }\n  }\n\n  return array_buffer;\n}\n"],"names":["WaveformDataChannel","waveformData","channelIndex","this","_waveformData","_channelIndex","prototype","min_sample","index","offset","channels","_at","max_sample","set_min_sample","sample","_set_at","set_max_sample","min_array","length","values","i","push","max_array","INT8_MAX","INT8_MIN","INT16_MAX","INT16_MIN","generateWaveformData","options","scale","amplitude_scale","split_channels","sample_rate","map","channel","Float32Array","output_channels","data_length","audio_sample_count","Math","floor","calculateWaveformDataLength","bytes_per_sample","bits","buffer","ArrayBuffer","data_view","DataView","scale_counter","min_value","Array","max_value","Infinity","range_min","range_max","setInt32","setUint32","setInt8","setInt16","isNullOrUndefined","value","WaveformData","data","_typeof","isJsonWaveformData","expected_length","Error","total_size","array_buffer","data_object","samples_per_pixel","convertJsonToBinary","isCompatible","version","getInt32","TypeError","isBinaryWaveformData","_data","_offset","_version","_channels","defaultOptions","createFromAudioBuffer","audio_buffer","callback","numberOfChannels","getChannelData","disable_worker","sampleRate","undefined","worker","WaveformDataWorker","onmessage","evt","postMessage","WaveformResampler","_inputData","_output_samples_per_pixel","_scale","_input_buffer_size","input_buffer_length_samples","output_buffer_length_samples","ceil","_output_data","output_dataview","_outputWaveformData","_input_index","_output_index","_min","_max","_min_value","_max_value","_where","_prev_where","_stop","_last_input_index","create","createFromAudio","opts","getOptions","audio_context","audioContext","audioData","errorCallback","error","DOMException","promise","decodeAudioData","catch","createFromArrayBuffer","sample_at_pixel","x","next","count","getOutputData","_getResampleOptions","width","RangeError","duration","abortSignal","resample","resampler","concat","self","otherWaveforms","slice","call","arguments","forEach","otherWaveform","combinedBuffer","_concatBuffers","apply","headerSize","totalSize","totalDataLength","bufferCollection","w","dataSize","byteLength","totalBuffer","sourceHeader","totalBufferView","setUint8","getUint8","dataOfTotalBuffer","Uint8Array","set","startIndex","endIndex","startTime","endTime","at_time","output_data","getUint32","Boolean","pixels_per_second","seconds_per_pixel","getInt8","getInt16","time","toJSON","waveform","toArrayBuffer"],"mappings":"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"}